---
description: 
globs: 
alwaysApply: false
---
# 项目架构原则

本文档概述了量化交易项目的架构原则和指导方针。目标是在快速迭代、学习和构建可维护系统之间保持平衡。

## 核心理念 (灵感来自 project_development_philosophy.mdc)

*   **学习优先**: 主要目标是学习。实现功能是为了理解概念并获得实践经验。
*   **迭代开发**: 系统是逐步演进的。我们更倾向于构建和完善，而不是进行详尽的前期设计。
*   **实际应用**: 专注于可工作的组件。理论上的完美次于功能的实用性。
*   **最简可行文档**: 只记录理解和协作所必需的文档，而非为了文档本身而文档。

## 整体结构

项目大致分为三个主要部分：

1.  **核心引擎 (`core_engine/`)**: 包含数据处理、策略执行、投资组合管理和交易模拟的基础逻辑。
    *   **数据提供者**: 历史和实时数据的抽象及具体实现。
        *   `RealtimeDataProviderBase` (`core_engine/realtime_feed_base.py`)
        *   `MockRealtimeDataProvider` (`core_engine/realtime_feed.py`): 其实例化和配置（如模拟的股票代码）现在可以根据所选策略的要求由后端API动态设定。
        *   (未来: 历史数据接口、其他实时数据源)
    *   **策略**: 基类和具体的策略实现。这些策略可以被后端API根据用户请求动态选择、实例化和配置。
        *   `BaseStrategy` (`strategies/base_strategy.py`)
        *   `SimpleMAStrategy` (`strategies/simple_ma_strategy.py` - 用于回测)
        *   `RealtimeSimpleMAStrategy` (`strategies/simple_ma_strategy.py` - 用于实时模拟)
        *   `RealtimeRSIStrategy` (`strategies/realtime_rsi_strategy.py` - 用于实时模拟，基于RSI指标)
    *   **投资组合管理**: 跟踪头寸、现金和业绩。
        *   `MockPortfolio` (`core_engine/portfolio.py`)
    *   **交易引擎**: 模拟订单执行。
        *   `MockTradingEngine` (`core_engine/trading_engine.py`)
    *   **事件/信号系统**: (目前为隐式，如果需要则正式化) 如 `SignalEvent`, `DataTick` 等结构。

2.  **后端 API (`backend/`)**: 一个 FastAPI 应用程序，用于暴露核心引擎的功能并为前端提供数据。
    *   **主应用程序**: `backend/main_api.py`
    *   **API 端点**:\n        *   `/api/v1/strategies`: 获取可用回测策略列表。\n        *   `/api/v1/backtest/run`: 运行历史回测。
        *   `/api/simulation/status`: (GET) 获取当前实时模拟的详细状态，包括投资组合、最近交易、活动策略信息以及模拟是否正在运行。即使模拟已停止，只要状态未被清除，仍会返回最后的有效状态。
        *   `/api/simulation/available_strategies`: (GET) 提供一个当前后端注册的、可用于实时模拟的策略列表（含策略ID、名称、描述、参数规格）。供前端动态构建策略选择和参数配置界面。
        *   `/api/simulation/start`: (POST) 根据请求中指定的 `strategy_id`、`parameters` 和可选的 `initial_capital`，初始化并启动一个新的实时模拟会话。启动前会先调用内部逻辑彻底停止并清除任何先前的模拟状态，以确保全新的开始。
        *   `/api/simulation/stop`: (POST) 停止当前正在运行的实时模拟的核心活动部分（如数据提供者和策略的数据处理循环）。默认情况下，此操作会保留投资组合、交易引擎和策略信息的最终状态，以便用户查看。应用关闭时，会进行彻底的状态清除。
    *   **数据模型**: 用于 API 请求和响应的 Pydantic 模型。例如 `BacktestRequest`, `SimulationStatusResponse`, `AvailableStrategy`, `StartSimulationRequest` 等，确保了清晰的接口定义和数据校验。
    *   **全局模拟会话管理**: 后端维护一个全局状态来管理当前的实时模拟会话。这包括：
        *   **策略注册表 (`STRATEGY_REGISTRY`)**: 一个集中的地方，用于注册所有可用于实时模拟的策略（如 `RealtimeSimpleMAStrategy` 和 `RealtimeRSIStrategy`）及其元数据（如参数定义、描述等）。
        *   **动态组件生命周期**: 当收到 `/api/simulation/start` 请求时，后端会：
            1.  根据请求的 `strategy_id` 从策略注册表中查找策略。
            2.  动态实例化所需的核心引擎组件：`MockPortfolio` (使用请求的或默认的初始资金)，`MockTradingEngine`，特定策略实例 (如 `RealtimeSimpleMAStrategy` 或 `RealtimeRSIStrategy`，传递用户提供的参数)，以及 `MockRealtimeDataProvider` (根据策略参数配置，例如股票代码 `symbol`)。
            3.  将这些组件关联起来（例如，策略的信号回调连接到交易引擎）。
            4.  启动数据提供者和策略。
        *   **状态管理与启停**: 通过 `stop_current_simulation(clear_all_components: bool)` 内部函数控制模拟的停止。`clear_all_components=True` (如启动新模拟前或应用关闭时调用) 会完全清除所有组件实例和状态。`clear_all_components=False` (如 `/api/simulation/stop` 端点调用) 则只停止活动组件，保留投资组合等状态以供后续查询。

3.  **前端 UI (`frontend/`)**: 一个 React/Vite 应用程序，用于用户交互、显示结果和控制模拟。
    *   **结构**:\n        *   `src/`: 主要源代码。
        *   `src/App.tsx`: 主应用程序组件、选项卡切换（回测/实时模拟）、整体布局。
        *   `src/components/`: 可复用的 UI 组件。
            *   `BacktestForm.tsx`
            *   `BacktestResultDisplay.tsx`
            *   `StrategyControlPanel.tsx`: 允许用户选择可用策略、配置其参数、设置初始资金，并控制模拟的启动与停止。
            *   `SimulationDisplay.tsx` (及其子组件: `PortfolioSummary`, `HoldingsTable`, `TradesList`, `StrategyInfoDisplay`): 动态显示模拟交易的状态信息。
        *   `src/api.ts`: 用于后端通信的函数，包括 `fetchAvailableStrategies`, `startSimulation`, `stopSimulation`, `fetchSimulationStatus` 等。
        *   `src/types.ts`: TypeScript 类型定义，与后端 Pydantic 模型对应。
    *   **状态管理**: 主要通过 React 组件状态 (useState, useEffect) 和 props。管理诸如可用策略列表、当前选定策略、参数值、模拟运行状态、API加载/错误状态等。
    *   **UI 库**: (目前为自定义 CSS 与 Tailwind CSS，如果后续为加快开发速度需要，可考虑组件库)。

## 通信流程

### 1. 获取和显示实时模拟状态 (定期轮询)

```mermaid
sequenceDiagram
    participant 用户
    participant 前端 (React UI)
    participant 后端 (FastAPI)
    participant 交易引擎
    participant 投资组合
    participant 当前策略实例
    participant 当前数据提供者实例

    用户->>前端: 查看模拟显示界面 (SimulationDisplay)
    loop 定期轮询 (若模拟运行中或有历史状态)
        前端->>后端: GET /api/simulation/status
        后端->>投资组合: 获取投资组合详情
        投资组合-->>后端: 投资组合数据 (现金, 持仓等)
        后端->>当前数据提供者实例: (若运行中) 获取持仓当前价格
        当前数据提供者实例-->>后端: 当前价格
        后端->>交易引擎: 获取最近交易记录
        交易引擎-->>后端: 交易日志
        后端->>当前策略实例: 获取策略名称和参数 (simulation_components.strategy_info)
        当前策略实例-->>后端: 策略详情
        后端-->>前端: SimulationStatusResponse
        前端->>用户: 更新 UI (投资组合, 交易, 策略信息)
    end

    Note over 当前数据提供者实例, 当前策略实例: 实时数据流与信号处理 (后台运行)
    当前数据提供者实例->>当前策略实例: on_new_tick(data)
    当前策略实例->>交易引擎: process_signal(signal_event)
    交易引擎->>投资组合: execute_trade(trade_details)
```

### 2. 启动新的实时模拟

```mermaid
sequenceDiagram
    participant 用户
    participant 前端 (StrategyControlPanel)
    participant 后端 (FastAPI API)
    participant 策略注册表 (STRATEGY_REGISTRY)
    participant 核心引擎 (动态实例化)

    用户->>前端: 选择策略 (例如："实时简单MA" 或 "实时RSI震荡策略")
    用户->>前端: 配置参数 (例如：symbol="MSFT", short_window=5, long_window=10 或 period=14, oversold=30, overbought=70)
    用户->>前端: 设置初始资金 (例如：10万元)
    用户->>前端: 点击 "启动模拟" 按钮
    前端->>后端 (FastAPI API): POST /api/simulation/start (payload: {strategy_id, parameters, initial_capital})
    后端 (FastAPI API)->>后端 (FastAPI API): stop_current_simulation(clear_all_components=True) (停止并清理旧模拟)
    后端 (FastAPI API)->>策略注册表 (STRATEGY_REGISTRY): 查询 strategy_id 定义
    策略注册表 (STRATEGY_REGISTRY)-->>后端 (FastAPI API): 返回策略类和元数据
    后端 (FastAPI API)->>核心引擎 (动态实例化): 创建 MockPortfolio (含初始资金)
    后端 (FastAPI API)->>核心引擎 (动态实例化): 创建 MockTradingEngine (关联Portfolio)
    后端 (FastAPI API)->>核心引擎 (动态实例化): 创建 MockRealtimeDataProvider (根据策略参数配置symbol等)
    后端 (FastAPI API)->>核心引擎 (动态实例化): 创建 选定策略实例 (例如 RealtimeSimpleMAStrategy 或 RealtimeRSIStrategy，关联DataProvider，信号回调至Engine)
    后端 (FastAPI API)->>核心引擎 (动态实例化): 调用 DataProvider.start() 和 Strategy.start()
    核心引擎 (动态实例化)-->>后端 (FastAPI API): 组件启动成功
    后端 (FastAPI API)-->>前端: 返回成功消息 (例如："模拟已启动")
    前端->>用户: 显示成功消息，UI更新模拟状态 (例如，禁用控制按钮，触发status轮询)
```

## 未来开发的关键设计原则

*   **模块化**: 尽可能保持组件解耦 (例如，数据提供者、策略、投资组合)。
*   **抽象化**: 使用基类和接口以允许不同的实现 (例如，不同的数据源、不同的策略类型)。
*   **可测试性**: 设计组件使其易于独立测试。鼓励进行单元测试和集成测试。
*   **配置化**: 将配置外部化 (例如，API 密钥、策略参数)，而不是硬编码。
*   **可扩展性**: 设计时考虑到未来的增强功能 (例如，添加新策略、支持不同资产类别)。

本文档应随着项目的演进而更新。
